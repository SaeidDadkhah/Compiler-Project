%{
  package jSHLang;
  
  import java.io.*;
  import java.util.ArrayList;
%}

%token <EVal> PROGRAM_KW MAIN_KW PROCEDURE_KW INTEGER_KW REAL_KW CHAR_KW BOOLEAN_KW IF_KW THEN_KW ELSE_KW DO_KW WHILE_KW FOR_KW IN_KW REPEAT_KW SWITCH_KW CASE_KW DEFAULT_KW END_KW RETURN_KW EXIT_KW WHEN_KW AND_KW AND_THEN_KW OR_KW OR_ELSE_KW NOT_KW SEMICOLON_KW COLON_KW COMMA_KW ASS_KW LP_KW RP_KW LB_KW RB_KW LCB_KW RCB_KW TWO_DOTS_KW EQ_KW NE_KW LE_KW LT_KW GE_KW GT_KW ADD_KW SUB_KW MUL_KW DIV_KW MOD_KW

%token <EVal> IDENTIFIER
%type <EVal> saved_identifier
%token <EVal> INTEGER_CONSTANT
%type <EVal> saved_integer
%token <EVal> REAL_CONSTANT
%type <EVal> saved_real
%token <EVal> CHAR_CONSTANT
%type <EVal> saved_char
%token <EVal> BOOLEAN_CONSTANT
%type <EVal> saved_boolean

%type <EVal> type_specifiers declarator_list declarator declarator_end dec initializer initializer_end initializer_list initializer_list_in_cb range block statement_list statement matched unmatched other_statement expressions constant_expressions bool_expressions arithmatic_expressions
%type <EVal> M N

%code {

	public static final String TYPE_STRING_INTEGER = "int";
	public static final String TYPE_STRING_REAL = "double";
	public static final String TYPE_STRING_CHAR = "char";
	public static final String TYPE_STRING_BOOLEAN = "int";

	private static final String tempStr = "__SHLangTempVar";
	public static final String startStr = "__SHLangStartVar";
	public static final String sizeStr = "__SHLangSizeVar";
	public static final String indexStr = "__SHLangIndexVar";
	public static final String condStr = "__SHLangConditionVar";
	
	public static String lexIdentifier;
	public static int lexInt;
	public static double lexReal;
	public static boolean lexBoolean;
	public static char lexChar;

	private ArrayList<Quadruple> quadruples = new ArrayList<>();
	private SymbolTable symbolTable = new SymbolTable();
	public static PrintStream writer;

	private int tempCounter = 0;

	public String fileAddress;

	public static void main(String args[]) throws IOException {
		YYParser yyparser;
		final Yylex lexer;

		writer = new PrintStream(new File("output.txt"));
		lexer = new Yylex(new InputStreamReader(new FileInputStream(".\\files\\Code.shl")));

		yyparser = new YYParser(new Lexer() {

			@Override
			public int yylex() {
				int yyl_return = -1;
				try {
					yyl_return = lexer.yylex();
				} catch (IOException e) {
					System.err.println("IO error: " + e);
				}
				return yyl_return;
			}

			@Override
			public void yyerror(String error) {
				System.err.println("Error! " + error);
			}

			@Override
			public Object getLVal() {
				return null;
			}
		});
		yyparser.fileAddress = "E:\\Dev C++\\TEMP - Programs\\compiler.c";
		yyparser.parse();

		return;
	}

	private void emit(String operation, String arg0, String arg1, String result) {
		quadruples.add(new Quadruple(operation, arg0, arg1, result));
	}

	private void backpatch(ArrayList<Integer> list, int quadNumber) {
		for (int i = 0; i < list.size(); i++)
			quadruples.get(list.get(i)).result = String.valueOf(quadNumber);
	}

	private String newTemp(int type, boolean array) {
		String name = tempStr + tempCounter++;
		symbolTable.addToSymbolTable(name, type, array);
		return name;
	}

	private int nextQuad() {
		return quadruples.size();
	}

	private String getTypeString(int typeCode){
		switch(typeCode){
			case EVal.TYPE_CODE_INTEGER:
				return TYPE_STRING_INTEGER;
			case EVal.TYPE_CODE_REAL:
				return TYPE_STRING_REAL;
			case EVal.TYPE_CODE_CHAR:
				return TYPE_STRING_CHAR;
			case EVal.TYPE_CODE_BOOLEAN:
				return TYPE_STRING_BOOLEAN;
			case EVal.TYPE_CODE_UNKNOWN:
			case EVal.TYPE_CODE_RANGE:
			default:
				return null;
		}
	}

	private void exportIntermediateCode() {
		DataOutputStream dos = null;
		try {
			dos = new DataOutputStream(new FileOutputStream(fileAddress));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

		try {
			dos.writeBytes("#include <stdio.h>\n\nint main() {\n\t// ////////////////// Symbol Table \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\\n\n");
			dos.writeBytes(symbolTable.toString());
			dos.writeBytes("\n\t// ////////////////// Quadruples \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\\n\n");
			// Backpatch of error controllers.
			backpatch(EVal.arrayIndexOutOfBoundList, (quadruples.size() + 1)); // Array index out of bound error.
			backpatch(EVal.invalidArraySizeList, (quadruples.size() + 2)); // Invalid array size error.
			for (int i = 0; i < quadruples.size() && i < 100; i++) {
				if(quadruples.get(i).isDeclaration())
					dos.writeBytes("\t\t\t\t" + quadruples.get(i) + "\n");
				else
					dos.writeBytes(Quadruple.LINE_STR + i + ":" + "\t\t" + quadruples.get(i) + "\n");
			}
			for (int i = 100; i < quadruples.size(); i++) {
				if(quadruples.get(i).isDeclaration())
					dos.writeBytes("\t\t\t\t" + quadruples.get(i) + "\n");
				else
					dos.writeBytes(Quadruple.LINE_STR + i + ":" + "\t\t" + quadruples.get(i) + "\n");
			}
			// Normal Finish
			if(quadruples.size() < 100)
				dos.writeBytes(Quadruple.LINE_STR + quadruples.size() + ":" + "\t\tprintf(\"Process is terminated with no error.\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\t\treturn 0;\n");
			else
				dos.writeBytes(Quadruple.LINE_STR + quadruples.size() + ":" + "\t\tprintf(\"Process is terminated with no error.\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\t\treturn 0;\n");

			// Array index out of bound error.
			if(quadruples.size() < 100)
				dos.writeBytes(Quadruple.LINE_STR + (quadruples.size() + 1) + ":" + "\t\tprintf(\"Array Error: Index out of bound!\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\treturn -1;\n");
			else
				dos.writeBytes(Quadruple.LINE_STR + (quadruples.size() + 1) + ":" + "\t\tprintf(\"Array Error: Index out of bound!\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\treturn -1;\n");

			// Invalid array size error.
			if(quadruples.size() < 100)
				dos.writeBytes(Quadruple.LINE_STR + (quadruples.size() + 2) + ":" + "\t\tprintf(\"Array Error: Invalid array size!\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\treturn -1;\n");
			else
				dos.writeBytes(Quadruple.LINE_STR + (quadruples.size() + 2) + ":" + "\t\tprintf(\"Array Error: Invalid array size!\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\treturn -1;\n");

			dos.writeBytes("}");
		} catch (IOException e) {
			e.printStackTrace();
		}

	}
}

%left OR_KW OR_ELSE_KW
%left AND_KW AND_THEN_KW
%left EQ_KW NE_KW LE_KW LT_KW GE_KW GT_KW
%left ADD_KW SUB_KW
%left MUL_KW DIV_KW MOD_KW
%right NOT_KW usub

%%
program:
	PROGRAM_KW saved_identifier declarations_list procedure_list MAIN_KW block {
		System.out.println("Rule 1.1: " +
			"program: PROGRAM_KW saved_identifier declarations_list procedure_list MAIN_KW block");
		backpatch($6.nextList, nextQuad());
		exportIntermediateCode();
	}
	| PROGRAM_KW saved_identifier procedure_list MAIN_KW block {
		System.out.println("Rule 1.2: " +
			"program: PROGRAM_KW saved_identifier procedure_list MAIN_KW block");
		backpatch($5.nextList, nextQuad());
		exportIntermediateCode();
	}
	| PROGRAM_KW saved_identifier declarations_list MAIN_KW block {
		System.out.println("Rule 1.3: " +
			"program: PROGRAM_KW saved_identifier declarations_list MAIN_KW block");
		backpatch($5.nextList, nextQuad());
		exportIntermediateCode();
	}
	| PROGRAM_KW saved_identifier MAIN_KW block {
		System.out.println("Rule 1.4: " +
			"program: PROGRAM_KW saved_identifier MAIN_KW block");
		backpatch($4.nextList, nextQuad());
		exportIntermediateCode();
	}

declarations_list:
	declarations_list declarations {
		System.out.println("Rule 2.1: " +
			"declarations_list: declarations_list declarations");
	}
	| declarations{
		System.out.println("Rule 2.2: " +
			"declarations_list: declarations");
	}

declarations:
	type_specifiers declarator_list {
		System.out.println("Rule 3: " +
			"declarations: type_specifiers declarator_list");
		if($2.type == EVal.TYPE_CODE_UNKNOWN || $1.type == $2.type) {
			for(int i = 0; i < $2.initializersList.size(); i++) {
				if(symbolTable.lookUp(sizeStr + $2.declareds.get(i).place) == SymbolTable.NOT_IN_SYMBOL_TABLE) {
					symbolTable.addToSymbolTable($2.declareds.get(i).place, $1.type, false);
					if($2.initializersList.get(i) != null && $2.initializersList.get(i).size() == 1) {
						if($1.type != EVal.TYPE_CODE_BOOLEAN) {
							emit(":=", $2.initializersList.get(i).get(0).place, null, $2.declareds.get(i).place);
							switch ($1.type) {
								case EVal.TYPE_CODE_INTEGER:
									emit("iprint", null, null, $2.declareds.get(i).place);
									break;
								case EVal.TYPE_CODE_REAL:
									emit("rprint", null, null, $2.declareds.get(i).place);
									break;
								case EVal.TYPE_CODE_CHAR:
									emit("cprint", null, null, $2.declareds.get(i).place);
									break;
							}
						} else {
							// backpatch($2.initializersList.get(i).get(0).falseList, nextQuad());
							// backpatch($2.initializersList.get(i).get(0).trueList, nextQuad() + 2);
							emit(":=", "0", null, $2.declareds.get(i).place);
							emit("goto", null, null, String.valueOf(nextQuad() + 2));
							emit(":=", "1", null, $2.declareds.get(i).place);
							emit("bprint", null, null, $2.declareds.get(i).place);
						}
					} else if($2.initializersList.get(i) != null) {
						System.err.println("Error! Initializer number mismatch. (Expected: 1" + ", Number: " + $2.initializersList.get(i).size() + ")");
						return YYABORT;
					}
				} else {
					symbolTable.addToSymbolTable($2.declareds.get(i).place, $1.type, true);
					emit("[]", getTypeString($1.type), sizeStr + $2.declareds.get(i).place, $2.declareds.get(i).place);
					if($2.initializersList.get(i) != null) {
						for(int j = 0; j < $2.initializersList.get(i).size(); j++) {
							EVal.arrayIndexOutOfBoundList.add(nextQuad() + 1);
							emit(">=", String.valueOf(j), sizeStr + $2.declareds.get(i).place, condStr + $2.declareds.get(i).place);
							emit("check", condStr + $2.declareds.get(i).place, null, String.valueOf(nextQuad() + 2)); // Result will be backpatched.
							if($1.type != EVal.TYPE_CODE_BOOLEAN) {
								emit("[]=", $2.initializersList.get(i).get(j).place, String.valueOf(j), $2.declareds.get(i).place);
								emit("+", startStr + $2.declareds.get(i).place, String.valueOf(j), condStr + $2.declareds.get(i).place);
								switch ($1.type) {
									case EVal.TYPE_CODE_INTEGER:
										emit("aiprint", condStr + $2.declareds.get(i).place, String.valueOf(j), $2.declareds.get(i).place);
										break;
									case EVal.TYPE_CODE_REAL:
										emit("arprint", condStr + $2.declareds.get(i).place, String.valueOf(j), $2.declareds.get(i).place);
										break;
									case EVal.TYPE_CODE_CHAR:
										emit("acprint", condStr + $2.declareds.get(i).place, String.valueOf(j), $2.declareds.get(i).place);
										break;
								}
							} else {
								// backpatch($2.initializersList.get(i).get(j).falseList, nextQuad());
								// backpatch($2.initializersList.get(i).get(j).trueList, nextQuad() + 2);
								emit("[]=", "0", String.valueOf(j), $2.declareds.get(i).place);
								emit("goto", null, null, String.valueOf(nextQuad() + 2));
								emit("[]=", "1", String.valueOf(j), $2.declareds.get(i).place);
								emit("abprint", condStr + $2.declareds.get(i).place, String.valueOf(j), $2.declareds.get(i).place);
							}
						}
					}
				}
			}
		} else {
			System.err.println("Error! Type specifier type mismatch. (" + $1.type + ", " + $2.type + ")");
			return YYABORT;
		}
	}

type_specifiers:
	INTEGER_KW {
		System.out.println("Rule 4.1: " +
			"type_specifiers: INTEGER_KW");
		$$ = new EVal();
		((EVal)$$).type = EVal.TYPE_CODE_INTEGER;
	}
	| REAL_KW {
		System.out.println("Rule 4.2: " +
			"type_specifiers: REAL_KW");
		$$ = new EVal();
		((EVal)$$).type = EVal.TYPE_CODE_REAL;
	}
	| CHAR_KW {
		System.out.println("Rule 4.3: " +
			"type_specifiers: CHAR_KW");
		$$ = new EVal();
		((EVal)$$).type = EVal.TYPE_CODE_CHAR;
	}
	| BOOLEAN_KW {
		System.out.println("Rule 4.4: " +
			"type_specifiers: BOOLEAN_KW");
		$$ = new EVal();
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
	}

declarator_list:
	declarator_list declarator {
		System.out.println("Rule 5.1: " +
			"declarator_list: declarator declarator_List");
		if($1.type == EVal.TYPE_CODE_UNKNOWN
			|| $1.type == $2.type) {
			$$ = new EVal();
			((EVal)$$).type = $2.type;
			((EVal)$$).declareds = $1.declareds;
			((EVal)$$).declareds.add($2);
			((EVal)$$).initializersList = $1.initializersList;
			((EVal)$$).initializersList.add($2.initializers);
		} else {
			System.err.println("Error! Declarator type mismatch.");
			return YYABORT;
		}
	}
	| declarator_end {
		System.out.println("Rule 5.2: " +
			"delarator_list: declarator_end");
		$$ = new EVal();
		((EVal)$$).type = $1.type;
		((EVal)$$).declareds = EVal.makeInitializersOrDeclareds($1);
		((EVal)$$).initializersList = EVal.makeInitializersList($1.initializers);
	}

declarator:
	dec COMMA_KW {
		System.out.println("Rule 6.1: " +
			"declarator: dec COMMA_KW");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = EVal.TYPE_CODE_UNKNOWN;
		((EVal)$$).array = $1.array;
		((EVal)$$).initializers = null;
	}
	| dec ASS_KW initializer {
		System.out.println("Rule 6.2: " +
			"declarator: dec ASS_KW initializer");
		if($1.array != $3.array) {
			System.err.println("Error! Array mismatch: " + $1.place + " and " + $3.place + " are not the same.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $3.type;
		((EVal)$$).array = $1.array;
		((EVal)$$).initializers = $3.initializers;
	}
	
declarator_end:
	dec SEMICOLON_KW {
		System.out.println("Rule 6.1: " +
			"declarator_end: dec SEMICOLON_KW");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = EVal.TYPE_CODE_UNKNOWN;
		((EVal)$$).initializers = null;
	}
	| dec ASS_KW initializer SEMICOLON_KW {
		System.out.println("Rule 6.2: " +
			"declarator_end: dec ASS_KW initializer SEMICOLON_KW");
		if($1.array != $3.array) {
			System.err.println("Error! Array mismatch: " + $1.place + " and " + $3.place + " are not the same.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $3.type;
		((EVal)$$).array = $1.array;
		((EVal)$$).initializers = $3.initializers;
	}
	| dec ASS_KW initializer_end {
		System.out.println("Rule 6.3: " +
			"declarator_end: dec ASS_KW initializer_end");
		if($1.array != $3.array) {
			System.err.println("Error! Array mismatch: " + $1.place + " and " + $3.place + " are not the same.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $3.type;
		((EVal)$$).array = $1.array;
		((EVal)$$).initializers = $3.initializers;
	}

dec:
	saved_identifier {
		System.out.println("Rule 7.1: " +
			"dec: saved_identifier");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).array = false;
	}
	| saved_identifier LB_KW range RB_KW{
		System.out.println("Rule 7.2: " +
			"dec: saved_identifier LB_KW range RB_KW");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).array = true;

		symbolTable.addToSymbolTable(startStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", startStr + $3.place, null , startStr + ((EVal)$$).place);

		symbolTable.addToSymbolTable(sizeStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", sizeStr + $3.place, null , sizeStr + ((EVal)$$).place);

		symbolTable.addToSymbolTable(indexStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		symbolTable.addToSymbolTable(condStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
	}
	| saved_identifier LB_KW saved_integer RB_KW{
		System.out.println("Rule 7.3: " +
			"dec: saved_identifier LB_KW saved_integer RB_KW");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).array = true;

		symbolTable.addToSymbolTable(startStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", "0", null , startStr + ((EVal)$$).place);

		symbolTable.addToSymbolTable(sizeStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", $3.place, null , sizeStr + ((EVal)$$).place);

		symbolTable.addToSymbolTable(indexStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		symbolTable.addToSymbolTable(condStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
	}

range:
	saved_identifier TWO_DOTS_KW saved_identifier {
		System.out.println("Rule 8.1: " +
			"range: saved_identifier TWO_DOTS_KW saved_identifier");
		int index1 = symbolTable.lookUp($1.place);
		int index2 = symbolTable.lookUp($3.place);
		if (index1 == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + $1.place + "\" is not declared.");
			return YYABORT;
		}
		if (index2 == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + $3.place + "\" is not declared.");
			return YYABORT;
		}

		if(symbolTable.types.get(index1) != EVal.TYPE_CODE_INTEGER) {
			System.err.println("Error! Type mismatch: " + $1.place + "is not integer.");
			return YYABORT;
		}
		if(symbolTable.types.get(index2) != EVal.TYPE_CODE_INTEGER) {
			System.err.println("Error! Type mismatch: " + $3.place + "is not integer.");
			return YYABORT;
		}

		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_RANGE, true);
		((EVal)$$).type = EVal.TYPE_CODE_RANGE;
		((EVal)$$).array = true;

		// Set start and size
		symbolTable.addToSymbolTable(startStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		symbolTable.addToSymbolTable(sizeStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", $1.place, null , startStr + ((EVal)$$).place);
		emit("-", $3.place, $1.place , sizeStr + ((EVal)$$).place);
		emit("+", sizeStr + ((EVal)$$).place, "1", sizeStr + ((EVal)$$).place);

		// Check size
		symbolTable.addToSymbolTable(condStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		EVal.invalidArraySizeList.add(nextQuad() + 1);
		emit("<=", sizeStr + ((EVal)$$).place, "0", condStr + ((EVal)$$).place);
		emit("check", condStr + ((EVal)$$).place, null, String.valueOf(nextQuad() + 1));
	}
	| saved_integer TWO_DOTS_KW saved_integer {
		System.out.println("Rule 8.2: " +
			"range: saved_integer TWO_DOTS_KW saved_integer");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_RANGE, true);
		((EVal)$$).type = EVal.TYPE_CODE_RANGE;
		((EVal)$$).array = true;

		// Set start and size
		symbolTable.addToSymbolTable(startStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		symbolTable.addToSymbolTable(sizeStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", $1.place, null , startStr + ((EVal)$$).place);
		emit("-", $3.place, $1.place , sizeStr + ((EVal)$$).place);
		emit("+", sizeStr + ((EVal)$$).place, "1", sizeStr + ((EVal)$$).place);

		// Check size
		symbolTable.addToSymbolTable(condStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		EVal.invalidArraySizeList.add(nextQuad() + 1);
		emit("<=", sizeStr + ((EVal)$$).place, "0", condStr + ((EVal)$$).place);
		emit("check", condStr + ((EVal)$$).place, null, String.valueOf(nextQuad() + 1));
	}
	| arithmatic_expressions TWO_DOTS_KW arithmatic_expressions {
		System.out.println("Rule 8.3: " +
			"range: arithmatic_expressions TWO_DOTS_KW arithmatic_expressions");
		if($1.type != EVal.TYPE_CODE_INTEGER) {
			System.err.println("Error! Type mismatch: " + $1.place + "is not integer.");
			return YYABORT;
		}
		if($3.type != EVal.TYPE_CODE_INTEGER) {
			System.err.println("Error! Type mismatch: " + $3.place + "is not integer.");
			return YYABORT;
		}

		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_RANGE, true);
		((EVal)$$).type = EVal.TYPE_CODE_RANGE;
		((EVal)$$).array = true;

		// Set start and size
		symbolTable.addToSymbolTable(startStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		symbolTable.addToSymbolTable(sizeStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", $1.place, null , startStr + ((EVal)$$).place);
		emit("-", $3.place, $1.place , sizeStr + ((EVal)$$).place);
		emit("+", sizeStr + ((EVal)$$).place, "1", sizeStr + ((EVal)$$).place);

		// Check size
		symbolTable.addToSymbolTable(condStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		EVal.invalidArraySizeList.add(nextQuad() + 1);
		emit("<=", sizeStr + ((EVal)$$).place, "0", condStr + ((EVal)$$).place);
		emit("check", condStr + ((EVal)$$).place, null, String.valueOf(nextQuad() + 1));
	}
	
initializer:
	LCB_KW initializer_list_in_cb {
		System.out.println("Rule 9.1: " +
			"initializer: LCB_KW initializer_list RCB_KW");
		$$ = new EVal();
		((EVal)$$).type = $2.type;
		((EVal)$$).array = $2.array;
		((EVal)$$).initializers = $2.initializers;
	}
	| initializer_list {
		System.out.println("Rule 9.2: " +
			"initializer: initializer_list");
		$$ = new EVal();
		((EVal)$$).type = $1.type;
		((EVal)$$).array = $1.array;
		((EVal)$$).initializers = $1.initializers;
	}

initializer_list_in_cb:
	initializer_list constant_expressions RCB_KW {
		System.out.println("Rule 10.1: " +
			"initializer_list_in_cb: initializer_list constant_expressions RCB_KW");
		if($1.type == $2.type) {
			$$ = new EVal();
			((EVal)$$).type = $1.type;
			((EVal)$$).array = true;
			((EVal)$$).initializers = $1.initializers;
			((EVal)$$).initializers.add($2);
		} else {
			System.err.println("Error! " + "Initializer type mismatch.");
			return YYABORT;
		}
	}
	| constant_expressions RCB_KW {
		System.out.println("Rule 10.2: " +
			"initializer_list_in_cb: constant_expressions RCB_KW");
		$$ = new EVal();
		((EVal)$$).type = $1.type;
		((EVal)$$).array = true;
		((EVal)$$).initializers = EVal.makeInitializersOrDeclareds($1);
	}

initializer_list:
	initializer_list constant_expressions COMMA_KW {
		System.out.println("Rule 10.1: " +
			"initializer_list: constant_expressions COMMA_KW initializer_list");
		if($1.type == $2.type) {
			$$ = new EVal();
			((EVal)$$).type = $1.type;
			((EVal)$$).array = true;
			((EVal)$$).initializers = $1.initializers;
			((EVal)$$).initializers.add($2);
		} else {
			System.err.println("Error! Initializer type mismatch.");
			return YYABORT;
		}
	}
	| constant_expressions COMMA_KW {
		System.out.println("Rule 10.2: " +
			"initializer_list: constant_expressions COMMA_KW");
		$$ = new EVal();
		((EVal)$$).type = $1.type;
		((EVal)$$).array = false;
		((EVal)$$).initializers = EVal.makeInitializersOrDeclareds($1);
	}

initializer_end:
	initializer_list constant_expressions SEMICOLON_KW {
		System.out.println("Rule 10.2: " +
			"initializer_end: initializer_list constant_expressions SEMICOLON_KW");
		if($1.type == $2.type) {
			$$ = new EVal();
			((EVal)$$).type = $1.type;
			((EVal)$$).array = true;
			((EVal)$$).initializers = $1.initializers;
			((EVal)$$).initializers.add($2);
		} else {
			System.err.println("Error! Initializer type mismatch.");
			return YYABORT;
		}
	}
	| constant_expressions SEMICOLON_KW {
		System.out.println("Rule 10.2: " +
			"initializer_end: constant_expressions SEMICOLON_KW");
		$$ = new EVal();
		((EVal)$$).type = $1.type;
		((EVal)$$).array = false;
		((EVal)$$).initializers = EVal.makeInitializersOrDeclareds($1);
	}
	
procedure_list:
	procedure {
		System.out.println("Rule 11.1: " +
			"procedure_list: procedure");
	}
	| procedure_list procedure {
		System.out.println("Rule 11.2: " +
			"procedure_list: procedure_list procedure");
	}

procedure:
	PROCEDURE_KW saved_identifier parameters LCB_KW declarations_list block RCB_KW {
		System.out.println("Rule 12.1: " +
			"procedure: PROCEDURE_KW saved_identifier parameters LCB_KW declarations_list block RCB_KW");
	}
	| PROCEDURE_KW saved_identifier parameters LCB_KW block RCB_KW {
		System.out.println("Rule 12.2: " +
			"procedure: PROCEDURE_KW saved_identifier parameters LCB_KW block RCB_KW");
	}

parameters:
	LP_KW declarations_list RP_KW {
		System.out.println("Rule 13: " +
			"parameters: LP_KW declarations_list RP_KW");
	}
	| LP_KW RP_KW {
		System.out.println("Rule 13: " +
			"parameters: LP_KW RP_KW");
	}

block:
	LCB_KW statement_list RCB_KW {
		System.out.println("Rule 14.1: " +
			"block: LCB_KW statement_list RCB_KW ");
		$$ = new EVal();
		((EVal)$$).nextList = $2.nextList;
	}
	| LCB_KW RCB_KW {
		System.out.println("Rule 14.2: " +
			"block: LCB_KW RCB_KW ");
		$$ = new EVal();
		((EVal)$$).nextList = EVal.makeList(nextQuad());
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched
	}

statement_list:
	SEMICOLON_KW M {
		System.out.println("Rule 15.1: " +
			"statement_list: statement SEMICOLON_KW");
		$$ = new EVal();
		((EVal)$$).nextList = EVal.makeList($2.quad);
	}
	| statement SEMICOLON_KW M {
		System.out.println("Rule 15.2: " +
			"statement_list: statement SEMICOLON_KW");
		$$ = new EVal();
		((EVal)$$).nextList = $1.nextList;
	}
	| statement_list M statement SEMICOLON_KW {
		System.out.println("Rule 15.3: " +
			"statement_list: statement_list statement SEMICOLON_KW");
		$$ = new EVal();
		((EVal)$$).nextList = $3.nextList;
		backpatch($1.nextList, $2.quad);
	}

statement: 
	matched{
		System.out.println("Rule 26.1: " +
			"statement: matched");
	}
	| unmatched{
		System.out.println("Rule 26.2: " +
			"statement: unmatched");
	}
	
matched: 
	IF_KW bool_expressions THEN_KW M matched N ELSE_KW M matched {
		System.out.println("Rule 24.1: " +
			"matched: IF_KW bool_expressions THEN_KW matched ELSE_KW matched");
		$$ = new EVal();
		backpatch($2.trueList, $4.quad);
		backpatch($2.falseList, $8.quad);
		((EVal)$$).nextList = EVal.merge($5.nextList, $6.nextList);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).nextList, $9.nextList);
	}
	| other_statement {
		System.out.println("Rule 24.2: " +
			"matched: other_statement");
		$$ = new EVal();
		((EVal)$$).nextList = $1.nextList;
	}
	
unmatched: 
	 IF_KW bool_expressions THEN_KW M matched N ELSE_KW M unmatched {
		System.out.println("Rule 25.1: " +
			"unmatched: IF_KW bool_expressions THEN_KW matched ELSE_KW unmatched");
	}
	| IF_KW bool_expressions THEN_KW M statement {
		System.out.println("Rule 25.2: " +
			"unmatched: IF_KW bool_expressions THEN_KW statement");
	}


other_statement:
	saved_identifier ASS_KW expressions {
		System.out.println("Rule 16.1: " +
			"other_statement: saved_identifier ASS_KW expressions");
		int index = symbolTable.lookUp($1.place);
		if (index == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + $1.place + "\" is not declared.");
			return YYABORT;
		}
		if(symbolTable.types.get(index) != $3.type) {
			System.err.println("Error! Type mismatch: " + $1.place + ", " + $3.place);
			return YYABORT;
		}
		if (symbolTable.arrays.get(index)) {
			System.err.println("Error! \"" + lexIdentifier + "\" is an array, it can not be used without index.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = symbolTable.names.get(index);
		((EVal)$$).type = $3.type;
		if($3.type != EVal.TYPE_CODE_BOOLEAN) {
			((EVal)$$).nextList = $1.nextList;
			emit(":=", $3.place, null, $1.place);
			switch ($3.type) {
				case EVal.TYPE_CODE_INTEGER:
					emit("iprint", null, null, $1.place);
					break;
				case EVal.TYPE_CODE_REAL:
					emit("rprint", null, null, $1.place);
					break;
				case EVal.TYPE_CODE_CHAR:
					emit("cprint", null, null, $1.place);
					break;
			}
		} else {
			backpatch($3.falseList, nextQuad());
			backpatch($3.trueList, nextQuad() + 2);
			emit(":=", "0", null, ((EVal)$$).place);
			emit("goto", null, null, String.valueOf(nextQuad() + 2));
			emit(":=", "1", null, ((EVal)$$).place);
			emit("bprint", null, null, $1.place);
		}
		((EVal)$$).nextList = EVal.makeList(nextQuad());
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| saved_identifier LB_KW expressions RB_KW ASS_KW expressions {
		System.out.println("Rule 16.1: " +
			"other_statement: saved_identifier ASS_KW expressions");
		int index = symbolTable.lookUp($1.place);
		if (index == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + $1.place + "\" is not declared.");
			return YYABORT;
		}
		if(symbolTable.types.get(index) != $6.type) {
			System.err.println("Error! Type mismatch: " + $1.place + ", " + $3.place);
			return YYABORT;
		}
		if (!symbolTable.arrays.get(index)) {
			System.err.println("Error! \"" + lexIdentifier + "\" is not an array, it can not be used with index.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = symbolTable.names.get(index);
		((EVal)$$).type = $3.type;
		((EVal)$$).array = true;
		EVal.arrayIndexOutOfBoundList.add(nextQuad() + 2);
		EVal.arrayIndexOutOfBoundList.add(nextQuad() + 4);
		emit("-", $3.place, startStr + $1.place, indexStr + $1.place);
		emit(">=", indexStr + $1.place, sizeStr + $1.place, condStr + $1.place);
		emit("check", condStr + $1.place, null, String.valueOf(nextQuad() + 4)); // result will be backpatched.
		emit("<", indexStr + $1.place, "0", condStr + $1.place);
		emit("check", condStr + $1.place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		if($6.type != EVal.TYPE_CODE_BOOLEAN) {
			emit("[]=", $6.place, indexStr + $1.place, $1.place);
			switch ($6.type) {
				case EVal.TYPE_CODE_INTEGER:
					emit("aiprint", $3.place, indexStr + $1.place, $1.place);
					break;
				case EVal.TYPE_CODE_REAL:
					emit("arprint", $3.place, indexStr + $1.place, $1.place);
					break;
				case EVal.TYPE_CODE_CHAR:
					emit("acprint", $3.place, indexStr + $1.place, $1.place);
					break;
			}
		} else {
			backpatch($3.falseList, nextQuad());
			backpatch($3.trueList, nextQuad() + 2);
			emit("[]=", "0", indexStr + $1.place, ((EVal)$$).place);
			emit("goto", null, null, String.valueOf(nextQuad() + 2));
			emit("[]=", "1", indexStr + $1.place, ((EVal)$$).place);
			emit("abprint", $3.place, indexStr + $1.place, $1.place);
		}

		((EVal)$$).nextList = EVal.makeList(nextQuad());
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| DO_KW M statement WHILE_KW M bool_expressions {
		System.out.println("Rule 16.4: " +
			"other_statement: DO_KW statement WHILE_KW bool_expressions");
		$$ = new EVal();
		((EVal)$$).nextList = $6.falseList;

		backpatch($3.nextList, $5.quad);
		backpatch($6.trueList, $2.quad);
	}
	| FOR_KW saved_identifier IN_KW range N REPEAT_KW M block {
		System.out.println("Rule 16.5: " +
			"other_statement: FOR_KW saved_identifier IN_KW range N REPEAT_KW M block");
		int index = symbolTable.lookUp($2.place);
		if (index == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + $1.place + "\" is not declared.");
			return YYABORT;
		}
		if(symbolTable.types.get(index) != EVal.TYPE_CODE_INTEGER) {
			System.err.println("Error! Type mismatch: " + $1.place + ", Integer");
			return YYABORT;
		}
		if (symbolTable.arrays.get(index)) {
			System.err.println("Error! \"" + lexIdentifier + "\" is an array, it can not be used in for initializer.");
			return YYABORT;
		}
		
		$$ = new EVal();
		
		backpatch($5.nextList, nextQuad());
		backpatch($8.nextList, nextQuad() + 5);
		
		emit(":=", startStr + $4.place, null, $2.place);
		emit("-", $2.place, startStr + $4.place, condStr + $4.place);
		emit("<", condStr + $4.place, sizeStr + $4.place, condStr + $4.place);
		emit("check", condStr + $4.place, null, String.valueOf($7.quad));
		emit("goto", null, null, String.valueOf(nextQuad() + 3)); // result will be backpatched;
		emit("+", $2.place, "1", $2.place);
		emit("goto", null, null, String.valueOf(nextQuad() - 5));
		
		((EVal)$$).nextList = EVal.makeList(nextQuad() - 3);
	}
	| SWITCH_KW expressions caseelement default END_KW {
		System.out.println("Rule 16.6.1: " +
			"other_statement: SWITCH_KW expressions caseelement default END_KW");
	}
	| SWITCH_KW expressions caseelement END_KW {
		System.out.println("Rule 16.6.2: " +
			"other_statement: SWITCH_KW expressions caseelement END_KW");
	}
	| saved_identifier LP_KW arguments RP_KW {
		System.out.println("Rule 16.7.1: " +
			"other_statement: saved_identifier LP_KW arguments RP_KW");
	}
	| saved_identifier LP_KW RP_KW {
		System.out.println("Rule 16.7.2: " +
			"other_statement: saved_identifier LP_KW RP_KW");
	}
	| RETURN_KW expressions {
		System.out.println("Rule 16.8: " +
			"other_statement: RETURN_KW expressions");
	}
	| EXIT_KW WHEN_KW LP_KW bool_expressions RP_KW {
		System.out.println("Rule 16.9: " +
			"other_statement: EXIT_KW WHEN_KW LP_KW bool_expressions RP_KW");
	}
	| block {
		System.out.println("Rule 16.10: " +
			"other_statement: block");
	}

arguments:
	declarator_list {
		System.out.println("Rule 17.1: " +
			"arguments: declarator_list");
	}

caseelement:
	CASE_KW saved_integer COLON_KW block SEMICOLON_KW {
		System.out.println("Rule 18.1: " +
			"caseelement: CASE_KW saved_integer COLON_KW block SEMICOLON_KW");
	}
	| caseelement CASE_KW saved_integer COLON_KW block SEMICOLON_KW {
		System.out.println("Rule 18.2: " +
			"caseelement: caseelement CASE_KW saved_integer COLON_KW block SEMICOLON_KW");
	}

default:
	DEFAULT_KW COLON_KW block SEMICOLON_KW {
		System.out.println("Rule 19: " +
			"default: DEFAULT_KW COLON_KW block SEMICOLON_KW");
	}

expressions:
	constant_expressions {
		System.out.println("Rule 20.1: " +
			"expressions: constant_expressions");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		if(((EVal)$$).type != EVal.TYPE_CODE_BOOLEAN) {
			((EVal)$$).nextList = $1.nextList;	
		} else {
			((EVal)$$).trueList = $1.trueList;
			((EVal)$$).falseList = $1.falseList;
		}
	}
	| bool_expressions {
		System.out.println("Rule 20.2: " +
			"expressions: bool_expressions");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = $1.trueList;
		((EVal)$$).falseList = $1.falseList;
	}
	| arithmatic_expressions {
		System.out.println("Rule 20.3: " +
			"expressions: arithmatic_expressions");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).nextList = $1.nextList;
	}
	| saved_identifier {
		System.out.println("Rule 20.4: " +
			"expressions: saved_identifier");
		int index = symbolTable.lookUp($1.place);
		if (index == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + lexIdentifier + "\" is not declared.");
			return YYABORT;
		}
		if (symbolTable.arrays.get(index)) {
			System.err.println("Error! \"" + lexIdentifier + "\" is an array, it can not be used without index.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = symbolTable.names.get(index);
		((EVal)$$).type = symbolTable.types.get(index);
		if(((EVal)$$).type != EVal.TYPE_CODE_BOOLEAN) {
			// emit(":=", String.valueOf(lexInt), null, ((EVal)$$).place);
		} else {
			((EVal)$$).trueList = EVal.makeList(nextQuad());
			((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);

			emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
			emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
		}
	}
	| saved_identifier LB_KW expressions RB_KW {
		System.out.println("Rule 20.4: " +
			"expressions: saved_identifier LB_KW arithmatic_expressions RB_KW");
		int index = symbolTable.lookUp($1.place);
		if (index == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + lexIdentifier + "\" is not declared.");
			return YYABORT;
		}
		if (!symbolTable.arrays.get(index)) {
			System.err.println("Error! \"" + lexIdentifier + "\" is not an array, it can not be used with index.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = newTemp(symbolTable.types.get(index), false);
		((EVal)$$).type = symbolTable.types.get(index);
		EVal.arrayIndexOutOfBoundList.add(nextQuad() + 2);
		EVal.arrayIndexOutOfBoundList.add(nextQuad() + 4);
		emit("-", $3.place, startStr + $1.place, indexStr + $1.place);
		emit(">=", indexStr + $1.place, sizeStr + $1.place, condStr + $1.place);
		emit("check", condStr + $1.place, null, String.valueOf(nextQuad() + 3)); // Result will be backpatched.
		emit("<", indexStr + $1.place, "0", condStr + $1.place);
		emit("check", condStr + $1.place, null, String.valueOf(nextQuad() + 1)); // Result will be backpatched.
		if($3.type != EVal.TYPE_CODE_BOOLEAN) {
			emit("=[]", $1.place, indexStr + $1.place, ((EVal)$$).place);
		} else {
			((EVal)$$).trueList = EVal.makeList(nextQuad());
			((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);

			emit("checkarr", $1.place, indexStr + $1.place, String.valueOf(nextQuad() + 2)); // result will be backpatched.
			emit("goto", null, null, String.valueOf(nextQuad() + 1)); //result will be backpatched.
		}
	}
	| LP_KW expressions RP_KW {
		System.out.println("Rule 20.5: " +
			"expressions: LP_KW expressions RP_KW");
		$$ = new EVal();
		((EVal)$$).place = $2.place;
		((EVal)$$).type = $2.type;
		((EVal)$$).nextList = $2.nextList;
		((EVal)$$).trueList = $2.trueList;
		((EVal)$$).falseList = $2.falseList;
	}

constant_expressions:
	saved_integer {
		System.out.println("Rule 21.1: " +
			"constant_expressions: saved_integer");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).nextList = $1.nextList;
	}
	| saved_real {
		System.out.println("Rule 21.2: " +
			"constant_expressions: saved_real");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).nextList = $1.nextList;
	}
	| saved_char {
		System.out.println("Rule 21.3: " +
			"constant_expressions: saved_char");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).nextList = $1.nextList;
	}
	| saved_boolean {
		System.out.println("Rule 21.4: " +
			"constant_expressions: saved_boolean");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).trueList = $1.trueList;
		((EVal)$$).falseList = $1.falseList;
	}	

bool_expressions:
	expressions LT_KW expressions {
		System.out.println("Rule 22.1: " +
			"bool_expressions: expressions LT_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit("<", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions LE_KW expressions {
		System.out.println("Rule 22.2: " +
			"bool_expressions: expressions LE_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit("<=", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions GT_KW expressions {
		System.out.println("Rule 22.3: " +
			"bool_expressions: expressions GT_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit(">", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions GE_KW expressions {
		System.out.println("Rule 22.4: " +
			"bool_expressions: expressions GE_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit(">=", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions EQ_KW expressions {
		System.out.println("Rule 22.5: " +
			"bool_expressions: expressions EQ_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit("=", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions NE_KW expressions {
		System.out.println("Rule 22.6: " +
			"bool_expressions: expressions NE_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit("<>", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions AND_KW M expressions {
		System.out.println("Rule 22.7: " +
			"bool_expressions: expressions AND_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		backpatch($1.trueList, $3.quad);
		((EVal)$$).trueList = $4.trueList;
		((EVal)$$).falseList = EVal.merge($1.falseList, $4.falseList);
	}
	| expressions OR_KW M expressions {
		System.out.println("Rule 22.8: " +
			"bool_expressions: expressions OR_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		backpatch($1.falseList, $3.quad);
		((EVal)$$).trueList = EVal.merge($1.trueList, $4.trueList);
		((EVal)$$).falseList = $4.falseList;
	}
	| expressions AND_THEN_KW M expressions {
		System.out.println("Rule 22.9: " +
			"bool_expressions: expressions AND_THEN_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		
		backpatch($1.trueList, nextQuad());
		emit(":=", "1", null, ((EVal)$$).place);
		emit("goto", null, null, String.valueOf($3.quad));
		backpatch($1.falseList, nextQuad());
		emit(":=", "0", null, ((EVal)$$).place);
		emit("goto", null, null, String.valueOf($3.quad));
		backpatch($4.trueList, nextQuad());
		backpatch($4.falseList, nextQuad());
		emit("*", ((EVal)$$).place, $4.place, ((EVal)$$).place);
		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2));// result will be backpatched
		emit("goto", null, null, String.valueOf(nextQuad() + 1));// result will be backpatched
	}
	| expressions OR_ELSE_KW M expressions {
		System.out.println("Rule 22.10: " +
			"bool_expressions: expressions OR_ELSE_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		
		backpatch($1.trueList, nextQuad());
		emit(":=", "1", null, ((EVal)$$).place);
		emit("goto", null, null, String.valueOf($3.quad));
		backpatch($1.falseList, nextQuad());
		emit(":=", "0", null, ((EVal)$$).place);
		emit("goto", null, null, String.valueOf($3.quad));
		backpatch($4.trueList, nextQuad());
		backpatch($4.falseList, nextQuad());
		emit("+", ((EVal)$$).place, $4.place, ((EVal)$$).place);
		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2));
		emit("goto", null, null, String.valueOf(nextQuad() + 1));
	}
	| NOT_KW expressions {
		System.out.println("Rule 22.11: " +
			"bool_expressions: expressions NOT_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = $2.falseList;
		((EVal)$$).falseList = $2.trueList;
	}

arithmatic_expressions:
	expressions ADD_KW expressions {
		System.out.println("Rule 23.1: " +
			"arithmatic_expressions: expressions ADD_KW expressions");
		if(($1.type == EVal.TYPE_CODE_INTEGER && $3.type == EVal.TYPE_CODE_INTEGER)
			|| ($1.type == EVal.TYPE_CODE_REAL && $3.type == EVal.TYPE_CODE_REAL)
			|| ($1.type == EVal.TYPE_CODE_CHAR && $3.type == EVal.TYPE_CODE_CHAR)){
			$$ = new EVal();
			((EVal)$$).place = newTemp($1.type, false);
			((EVal)$$).type = $1.type;
			emit("+", $1.place, $3.place, ((EVal)$$).place);
		}
	}
	| expressions SUB_KW expressions {
		System.out.println("Rule 23.2: " +
			"arithmatic_expressions: expressions SUB_KW expressions");
		if(($1.type == EVal.TYPE_CODE_INTEGER && $3.type == EVal.TYPE_CODE_INTEGER)
			|| ($1.type == EVal.TYPE_CODE_REAL && $3.type == EVal.TYPE_CODE_REAL)
			|| ($1.type == EVal.TYPE_CODE_CHAR && $3.type == EVal.TYPE_CODE_CHAR)){
			$$ = new EVal();
			((EVal)$$).place = newTemp($1.type, false);
			((EVal)$$).type = $1.type;
			emit("-", $1.place, $3.place, ((EVal)$$).place);
		}
	}
	| expressions MUL_KW expressions {
		System.out.println("Rule 23.3: " +
			"arithmatic_expressions: expressions MUL_KW expressions");
		if(($1.type == EVal.TYPE_CODE_INTEGER && $3.type == EVal.TYPE_CODE_INTEGER)
			|| ($1.type == EVal.TYPE_CODE_REAL && $3.type == EVal.TYPE_CODE_REAL)){
			$$ = new EVal();
			((EVal)$$).place = newTemp($1.type, false);
			((EVal)$$).type = $1.type;
			emit("*", $1.place, $3.place, ((EVal)$$).place);
		}
	}
	| expressions DIV_KW expressions {
		System.out.println("Rule 23.3: " +
			"arithmatic_expressions: expressions DIV_KW expressions");
		if(($1.type == EVal.TYPE_CODE_INTEGER && $3.type == EVal.TYPE_CODE_INTEGER)
			|| ($1.type == EVal.TYPE_CODE_REAL && $3.type == EVal.TYPE_CODE_REAL)){
			$$ = new EVal();
			((EVal)$$).place = newTemp($1.type, false);
			((EVal)$$).type = $1.type;
			emit("/", $1.place, $3.place, ((EVal)$$).place);
		}
	}
	| expressions MOD_KW expressions {
		System.out.println("Rule 23.5: " +
			"arithmatic_expressions: expressions MOD_KW expressions");
		if(($1.type == EVal.TYPE_CODE_INTEGER && $3.type == EVal.TYPE_CODE_INTEGER)
			|| ($1.type == EVal.TYPE_CODE_REAL && $3.type == EVal.TYPE_CODE_REAL)){
			$$ = new EVal();
			((EVal)$$).place = newTemp($1.type, false);
			((EVal)$$).type = $1.type;
			emit("%", $1.place, $3.place, ((EVal)$$).place);
		}
	}
	| SUB_KW expressions %prec usub {
		System.out.println("Rule 23.6: " +
			"arithmatic_expressions: SUB_KW expressions");
		if($2.type == EVal.TYPE_CODE_INTEGER || $2.type == EVal.TYPE_CODE_REAL){
			$$ = new EVal();
			((EVal)$$).place = newTemp($2.type, false);
			((EVal)$$).type = $2.type;
			emit("usub", $2.place, null, ((EVal)$$).place);
		}
	}

saved_identifier:
	IDENTIFIER {
		System.out.println("Rule 24: " +
			"saved_identifier: IDENTIFIER");
		$$ = new EVal();
		((EVal)$$).place = lexIdentifier;
	}

saved_integer:
	INTEGER_CONSTANT {
		System.out.println("Rule 25: " +
			"saved_integer: INTEGER_CONSTANT");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_INTEGER, false);
		((EVal)$$).type = EVal.TYPE_CODE_INTEGER;
		((EVal)$$).nextList = EVal.makeList(nextQuad() + 1);

		emit(":=", String.valueOf(lexInt), null, ((EVal)$$).place);
	}

saved_real:
	REAL_CONSTANT {
		System.out.println("Rule 25: " +
			"saved_real: REAL_CONSTANT");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
		((EVal)$$).type = EVal.TYPE_CODE_REAL;
		((EVal)$$).nextList = EVal.makeList(nextQuad() + 1);

		emit(":=", String.valueOf(lexReal), null, ((EVal)$$).place);
	}

saved_char:
	CHAR_CONSTANT {
		System.out.println("Rule 25: " +
			"saved_char: CHAR_CONSTANT");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_CHAR, false);
		((EVal)$$).type = EVal.TYPE_CODE_CHAR;
		((EVal)$$).nextList = EVal.makeList(nextQuad() + 1);

		emit(":=", "'" + String.valueOf(lexChar) + "'", null, ((EVal)$$).place);
	}

saved_boolean:
	BOOLEAN_CONSTANT {
		System.out.println("Rule 25: " +
			"saved_boolean: BOOLEAN_CONSTANT");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		if(lexBoolean)
			emit(":=", "1", null, ((EVal)$$).place);
		else
			emit(":=", "0", null, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}

M:
	{
		$$ = new EVal();
		((EVal)$$).quad = nextQuad();
	}

N:
	{
		$$ = new EVal();
		((EVal)$$).nextList = EVal.makeList(nextQuad());
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}

%%
// Classes
// // EVal
class EVal {

	public static final int TYPE_CODE_UNKNOWN = -1;
	public static final int TYPE_CODE_INTEGER = 0;
	public static final int TYPE_CODE_REAL = 1;
	public static final int TYPE_CODE_CHAR = 2;
	public static final int TYPE_CODE_BOOLEAN = 3;
	public static final int TYPE_CODE_RANGE = 4;
	

	public String place;
	public int type;
	public boolean array;

	public int quad;

	public static ArrayList<Integer> arrayIndexOutOfBoundList = new ArrayList<>();
	public static ArrayList<Integer> invalidArraySizeList = new ArrayList<>();
	public ArrayList<Integer> nextList;
	public ArrayList<Integer> trueList;
	public ArrayList<Integer> falseList;

	public ArrayList<ArrayList<EVal>> initializersList;
	public ArrayList<EVal> declareds;

	public ArrayList<EVal> initializers;

	public EVal() {
	}

	public static ArrayList<Integer> makeList(int number) {
		ArrayList<Integer> result = new ArrayList<>();
		result.add(number);
		return result;
	}

	public static ArrayList<Integer> merge(ArrayList<Integer> al1, ArrayList<Integer> al2) {
		ArrayList<Integer> result = new ArrayList<>();
		result.addAll(al1);
		result.addAll(al2);
		return result;
	}

	public static ArrayList<ArrayList<EVal>> makeInitializersList(ArrayList<EVal> initializers) {
		ArrayList<ArrayList<EVal>> result = new ArrayList<>();
		result.add(initializers);
		return result;
	}

	public static ArrayList<EVal> makeInitializersOrDeclareds(EVal initializerOrdDeclared) {
		ArrayList<EVal> result = new ArrayList<>();
		result.add(initializerOrdDeclared);
		return result;
	}
}

// // Quadruple

/*  _____________________________________________________________________________
 * |                                                                             |
 * |                                  Quadruples                                 |
 * |_____________________________________________________________________________|
 * |             Statement             | Operation |    Arg0   |  Arg1 |  Result |
 * |___________________________________|___________|___________|_______|_________|
 * |               goto L              |    goto   |           |       |    L    |
 * |       if BOOLEAN then goto L      |   check   |  BOOLEAN  |       |    L    |
 * |   if BOOLEAN[INDEX] then goto L   |  checkarr |  BOOLEAN  | INDEX |    L    |
 * |            E = E1 < E2            |     <     |     E1    |   E2  |    E    |
 * |            E = E1 <= E2           |     <=    |     E1    |   E2  |    E    |
 * |            E = E1 > E2            |     >     |     E1    |   E2  |    E    |
 * |            E = E1 >= E2           |     >=    |     E1    |   E2  |    E    |
 * |            E = E1 == E2           |     =     |     E1    |   E2  |    E    |
 * |            E = E1 <> E2           |     <>    |     E1    |   E2  |    E    |
 * |            E = E1 + E2            |     +     |     E1    |   E2  |    E    |
 * |            E = E1 - E2            |     -     |     E1    |   E2  |    E    |
 * |            E = E1 * E2            |     *     |     E1    |   E2  |    E    |
 * |            E = E1 / E2            |     /     |     E1    |   E2  |    E    |
 * |            E = E1 % E2            |     %     |     E1    |   E2  |    E    |
 * |              E = -E1              |    usub   |     E1    |       |    E    |
 * |               E = E1              |     :=    |     E1    |       |    E    |
 * |               TYPE E              |    init   |    TYPE   |       |    E    |
 * |        printf("E = E.val")        |   iprint  |           |       |   int   |
 * |        printf("E = E.val")        |   rprint  |           |       |   real  |
 * |        printf("E = E.val")        |   cprint  |           |       |   char  |
 * |        printf("E = E.val")        |   bprint  |           |       | boolean |
 * | printf("E[PLACE] = E[INDEX].val") |  aiprint  |   PLACE   | INDEX |   int   |
 * | printf("E[PLACE] = E[INDEX].val") |  arprint  |   PLACE   | INDEX |   real  |
 * | printf("E[PLACE] = E[INDEX].val") |  acprint  |   PLACE   | INDEX |   char  |
 * | printf("E[PLACE] = E[INDEX].val") |  abprint  |   PLACE   | INDEX | boolean |
 * |          TYPE NAME[SIZE]          |     []    |    TYPE   |  SIZE |   NAME  |
 * |           E[INDEX] = E1           |    []=    |     E1    | INDEX |    E    |
 * |           E = E1[INDEX]           |    =[]    |     E1    | INDEX |    E    |
 * |___________________________________|___________|___________|_______|_________|
 */
class Quadruple {

	public static final String LINE_STR = "Line";

	public String operation;
	public String arg0;
	public String arg1;
	public String result;

	public Quadruple(String operation, String arg0, String arg1, String result) {
		this.operation = operation;
		this.arg0 = arg0;
		this.arg1 = arg1;
		this.result = result;
	}

	public boolean isDeclaration() {
		return operation.equals("[]");
	}

	@Override
	public String toString() {
		switch(operation.toLowerCase()){
			case "goto":
				return operation + " " + LINE_STR + result + ";";
			case "check":
				return "if (" + arg0 + ") goto " + LINE_STR + result + ";";
			case "checkarr":
				return "if (" + arg0 + "[" + arg1 + "]) goto " + LINE_STR + result + ";";
			case "<":
			case "<=":
			case ">":
			case ">=":
			case "<>":
			case "+":
			case "-":
			case "*":
			case "/":
			case "%":
				return result + " = " + arg0 + " " + operation + " " + arg1 + ";";
			case "=":
				return result + " = " + arg0 + " " + "==" + " " + arg1 + ";";
			case "usub":
				return result + " = -" + arg0 + ";";
			case ":=":
				return result + " = " + arg0 + ";";
			case "init":
				return arg1 + " " + result + ";";
			case "iprint":
				return "printf(\"%s = %d\\n\", \"" + result + "\", " + result + ");";
			case "rprint":
				return "printf(\"%s = %f\\n\", \"" + result + "\", " + result + ");";
			case "cprint":
				return "printf(\"%s = '%c'\\n\", \"" + result + "\", " + result + ");";
			case "bprint":
				return "printf(\"%s = %s\\n\", \"" + result + "\", " + result + " ? \"true\" : \"false\");";
			case "aiprint":
				return "printf(\"%s[%d] = %d\\n\", \"" + result + "\", " + arg0 + ", " + result + "[" + arg1 + "]);";
			case "arprint":
				return "printf(\"%s[%d] = %f\\n\", \"" + result + "\", " + arg0 + ", " + result + "[" + arg1 + "]);";
			case "acprint":
				return "printf(\"%s[%d] = '%c'\\n\", \"" + result + "\", " + arg0 + ", " + result + "[" + arg1 + "]);";
			case "abprint":
				return "printf(\"%s[%d] = %s\\n\", \"" + result + "\", " + arg0 + ", " + result + "[" + arg1 + "] ? \"true\" : \"false\");";
			case "[]":
				return arg0 + " " + result + "[" + arg1 + "];";
			case "[]=":
				return result + "[" + arg1 + "] = " + arg0 + ";";
			case "=[]":
				return result + " = " + arg0 + "[" + arg1 + "];";
			default:
				return null;
		}
	}
}

// Symbol Table
class SymbolTable {

	public static final int NOT_IN_SYMBOL_TABLE = -1;

	public ArrayList<String> names;
	public ArrayList<Integer> types;
	public ArrayList<Boolean> arrays;

	public SymbolTable() {
		names = new ArrayList<>();
		types = new ArrayList<>();
		arrays = new ArrayList<>();
	}

	public int lookUp(String name) {
		return names.indexOf(name);
	}

	public boolean addToSymbolTable(String name, int type, boolean array) {
		if (lookUp(name) == -1) {
			names.add(name);
			types.add(type);
			arrays.add(array);
			return true;
		}
		return false;
	}

	@Override
	public String toString() {
		if(names.size() == 0)
			return null;
		String res = "";
		for(int i = 0; i < names.size(); i++) {
			if(arrays.get(i))
				continue;
			switch (types.get(i)) {
				case EVal.TYPE_CODE_INTEGER:
					res += "\t" + YYParser.TYPE_STRING_INTEGER;
					break;
				case EVal.TYPE_CODE_REAL:
					res += "\t" + YYParser.TYPE_STRING_REAL;
					break;
				case EVal.TYPE_CODE_CHAR:
					res += "\t" + YYParser.TYPE_STRING_CHAR;
					break;
				case EVal.TYPE_CODE_BOOLEAN:
					res += "\t" + YYParser.TYPE_STRING_BOOLEAN;
					break;
			}
			res += " " + names.get(i) + ";\n";
		}
		return res;
	}

}